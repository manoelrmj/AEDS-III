#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language brazilian
\language_package none
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3cm
\rightmargin 2.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Trabalho Prático 2: The Force Awakens
\end_layout

\begin_layout Author
Manoel da Rocha Miranda Júnior {manoelrmj@dcc.ufmg.br}
\end_layout

\begin_layout Section
Introdução
\end_layout

\begin_layout Standard
Este trabalho prático tem como objetivo solucionar um problema de otimização
 que consiste em minimizar a maior sub-distância percorrida por uma nave
 ao percorrer um trecho onde existem paradas.
 A nave em questão sai de um ponto de partida e percorre uma rota composta
 por planetas até alcançar um ponto de chegada.
 Os pontos de início e fim não são considerados planetas e a rota consiste
 em uma linha reta.
 A nave faz paradas nos planetas presentes na rota para fins de reparo e,
 como ela se encontra em fase de teste de suas operações, idealmente ela
 deve percorrer a menor distância possível até que seja feita outra parada
 para reparos.
 Desta forma, a solução do problema se resume em encontrar o menor valor
 da maior distância que pode ser percorrida pela nave sendo que, de um conjunto
 de N planetas, deseja-se reconquistar (e portanto, realizar paradas) em
 K elementos deste conjunto.
\end_layout

\begin_layout Standard
Neste trabalho prático, a solução para este problema é implementada a partir
 de três paradigmas diferentes, sendo eles:
\end_layout

\begin_layout Itemize
Programação Dinâmica
\end_layout

\begin_layout Itemize
Algorítmo Guloso
\end_layout

\begin_layout Itemize
Força Bruta
\end_layout

\begin_layout Section
Solução
\end_layout

\begin_layout Standard
O problema foi modelado em um simples arranjo contendo as distâncias.
 Para cada algorítmo criado a partir de um dado paradigma, foi tido como
 entrada o arranjo de distâncias, o número de planetas na rota e o número
 de planetas que devem ser reconquistados.
 A seguir estão descritas as soluções implementadas bem como uma imagem
 ilustrando a representação do problema.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/manoel/Documents/AEDS-III/TPs/TP2/assets/Screenshot from 2015-11-16 22:44:54.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Representação de uma instância do problema.
 Neste caso, onde de 4 planetas conquistam-se 3, a solução ótima tem como
 maior distância 8, ao não visitar o planeta 2.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Algorítmo Guloso
\end_layout

\begin_layout Standard
Na estratégia gulosa, o algorítmo se baseia no número de planetas que não
 serão visitados e, portanto, que podem ser 
\begin_inset Quotes eld
\end_inset

removidos
\begin_inset Quotes erd
\end_inset

 da rota de forma a unificar as arestas correspondentes à estes planetas.
 Primeiramente é criado uma cópia do vetor de distâncias objetivando sua
 manipulação sem alterar a entrada previamente lida.
 Em um loop que é executado N-K vezes, o arranjo de distâncias é percorrido
 e cada distância lida é somada com a distância subsequente de forma a obter
 a distância que seria percorrida ao eliminar um planeta.
 Das distâncias calculadas é obtida a menor e o planeta correspondente é
 então desconsiderado por meio de um deslocamento do vetor.
 Ao final das N-K iterações, N-K planetas terão sidos desconsiderados e,
 no arranjo remanescente desta operação, estarão contidas as distâncias
 correspondentes à soma das arestas unificadas na remoção de cada planeta.
 Desta forma, a cada iteração o algorítmo busca eliminar o melhor planeta
 até o momento (neste caso, aquele cuja eleminação criará uma aresta com
 a menor distância).
 A seguir um pseudo-código que representa sua execução:
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

// Encontra o melhor planeta a ser eliminado até o momento
\end_layout

\begin_layout Plain Layout

for(i=0 até N-K){
\end_layout

\begin_layout Plain Layout

	for(j=0 até numArestas-1){
\end_layout

\begin_layout Plain Layout

		if(distancia[j] + distancia[j+1] < tmpDistancia){
\end_layout

\begin_layout Plain Layout

			tmpDistancia = distancia[j] + distancia[j+1];
\end_layout

\begin_layout Plain Layout

			tmpPlaneta = j;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	// Desloca o vetor para o planeta eliminado
\end_layout

\begin_layout Plain Layout

	for(j=tmpPlaneta+1 até numArestas)
\end_layout

\begin_layout Plain Layout

		distancia[j] = distancia[j+1];
\end_layout

\begin_layout Plain Layout

	numArestas--;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// Dentre as distâncias calculadas, encontra a maior
\end_layout

\begin_layout Plain Layout

for(j=0 até numArestas){
\end_layout

\begin_layout Plain Layout

	if(distancia[j] > maiorDistancia)
\end_layout

\begin_layout Plain Layout

		maiorDistancia = distancia[j];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Retorna maiorDistancia;
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-código para a estratégia gulosa
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na solução proposta, o algorítmo guloso nem sempre fornece a resposta correta.
 Tomemos como exemplo o caso em que existem 9 planetas dos quais 2 serão
 conquistados sendo a distâncias 11 / 1 / 1 / 1 / 1 / 1 / 1 / 1 / 1 / 1
 / 11.
 Na solução gulosa proposta haverá seleção dos planetas com menor peso de
 distâncias.
 Para essa instância, a escolha ótima a cada iteração do algorítmo de forma
 a eliminar esses planetas não leva à solução ótima.
 A imagem abaixo mostra como o arranjo de distâncias é alterado a cada iteração
 do algorítmo:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/manoel/Documents/AEDS-III/TPs/TP2/assets/Screenshot from 2015-11-16 23:39:01.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Alteração do arranjo de distâncias a cada iteração do algorítmo guloso
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A saída do algorítmo neste caso seria 18.
 Entretanto, na solução ótima, a maior distância percorrida seria 15.
 Como o algorítmo guloso toma uma decisão que aparentemente leva à solução
 ótima em um dado momento e não volta atrás na mesma, caso exista um planeta
 cuja não visitação implicasse em uma sub-distância menor, esta possibilidade
 não será considerada.
 
\end_layout

\begin_layout Standard
// Discutir testes para o qual da certo.
\end_layout

\begin_layout Subsection
Força Bruta
\end_layout

\begin_layout Standard
A estratégia de solução do problema por força bruta consiste simplesmente
 em gerar todas as possíveis combinações de K planetas no conjunto de N
 unidades.
 Para cada combinação gerada é verificada qual a maior distância percorrida
 pela nave ao visitar os planetas em questão na combinação formada.
 Este valor é registrado e então comparado e atualizado a cada combinação
 até que se encontre o menor valor para a maior distância percorrida.
 Tomando como exemplo a seguinte entrada, sendo N = 3 e K = 2:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/manoel/Documents/AEDS-III/TPs/TP2/assets/entrada_simples.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Exemplo de instância
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
temos como resultado as seguintes combinações:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Planetas a visitar
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Distância Máxima percorrida
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1, 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1, 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2, 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Depois de analisada cada combinação e calculada a distância máxima percorrida,
 é feito uma busca pela menor distância dentre as distâncias encontradas.
 No caso em questão, a solução ótima consiste em visitar os planetas 2 e
 3, sendo a maior distância igual a 3.
\end_layout

\begin_layout Standard
Este é um algorítmo que não se mostra muito eficiente para grandes instâncias,
 uma vez que o número de combinações pode ser muito grande.
 Dado o conjunto de N planetas sendo K o número de visitados, o total de
 combinações é dado por 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
C=\frac{N!}{K!(N-K)!}
\]

\end_inset


\end_layout

\begin_layout Standard
A seguir está descrito o pseudo-código para a solução implementada:
\end_layout

\begin_layout Subsection
Programação Dinâmica
\end_layout

\begin_layout Section
Análise de custo
\end_layout

\begin_layout Subsection
Análise Teórica do Custo Assintótico de Tempo
\end_layout

\begin_layout Subsubsection
Algorítmo Guloso
\end_layout

\begin_layout Subsubsection
Força Bruta
\end_layout

\begin_layout Subsubsection
Programação Dinâmica
\end_layout

\begin_layout Subsection
Análise Teórica do Custo Assintótico de Espaço
\end_layout

\begin_layout Subsubsection
Algorítmo Guloso
\end_layout

\begin_layout Subsubsection
Força Bruta
\end_layout

\begin_layout Subsubsection
Programação Dinâmica
\end_layout

\begin_layout Section
Análise experimental
\end_layout

\begin_layout Subsection
Algorítmo Guloso
\end_layout

\begin_layout Subsection
Força Bruta
\end_layout

\begin_layout Subsection
Programação Dinâmica
\end_layout

\begin_layout Section
Conclusão
\end_layout

\end_body
\end_document
