#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language brazilian
\language_package none
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3cm
\rightmargin 2.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Trabalho Prático 2: The Force Awakens
\end_layout

\begin_layout Author
Manoel da Rocha Miranda Júnior {manoelrmj@dcc.ufmg.br}
\end_layout

\begin_layout Section
Introdução
\end_layout

\begin_layout Standard
Este trabalho prático tem como objetivo solucionar um problema de otimização
 que consiste em minimizar a maior sub-distância percorrida por uma nave
 ao percorrer um trecho onde existem paradas.
 A nave em questão sai de um ponto de partida e percorre uma rota composta
 por planetas até alcançar um ponto de chegada.
 Os pontos de início e fim não são considerados planetas e a rota consiste
 em uma linha reta.
 A nave faz paradas nos planetas presentes na rota para fins de reparo e,
 como ela se encontra em fase de teste de suas operações, idealmente ela
 deve percorrer a menor distância possível até que seja feita outra parada
 para reparos.
 Desta forma, a solução do problema se resume em encontrar o menor valor
 da maior distância que pode ser percorrida pela nave sendo que, de um conjunto
 de N planetas, deseja-se reconquistar (e portanto, realizar paradas) em
 K elementos deste conjunto.
\end_layout

\begin_layout Standard
Neste trabalho prático, a solução para este problema é implementada a partir
 de três paradigmas diferentes, sendo eles:
\end_layout

\begin_layout Itemize
Programação Dinâmica
\end_layout

\begin_layout Itemize
Algorítmo Guloso
\end_layout

\begin_layout Itemize
Força Bruta
\end_layout

\begin_layout Section
Solução
\end_layout

\begin_layout Standard
O problema foi modelado em um simples arranjo contendo as distâncias.
 Para cada algorítmo criado a partir de um dado paradigma, foi tido como
 entrada o arranjo de distâncias, o número de planetas na rota e o número
 de planetas que devem ser reconquistados.
 A seguir estão descritas as soluções implementadas bem como uma imagem
 ilustrando a representação do problema.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/manoel/Documents/AEDS-III/TPs/TP2/assets/Screenshot from 2015-11-16 22:44:54.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Representação de uma instância do problema.
 Neste caso, onde de 4 planetas conquistam-se 3, a solução ótima tem como
 maior distância 8, ao não visitar o planeta 2.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Algorítmo Guloso
\end_layout

\begin_layout Standard
Na estratégia gulosa, o algorítmo se baseia no número de planetas que não
 serão visitados e, portanto, que podem ser 
\begin_inset Quotes eld
\end_inset

removidos
\begin_inset Quotes erd
\end_inset

 da rota de forma a unificar as arestas correspondentes à estes planetas.
 Primeiramente é criado uma cópia do vetor de distâncias objetivando sua
 manipulação sem alterar a entrada previamente lida.
 Em um loop que é executado N-K vezes, o arranjo de distâncias é percorrido
 e cada distância lida é somada com a distância subsequente de forma a obter
 a distância que seria percorrida ao eliminar um planeta.
 Das distâncias calculadas é obtida a menor e o planeta correspondente é
 então desconsiderado por meio de um deslocamento do vetor.
 Ao final das N-K iterações, N-K planetas terão sidos desconsiderados e,
 no arranjo remanescente desta operação, estarão contidas as distâncias
 correspondentes à soma das arestas unificadas na remoção de cada planeta.
 Desta forma, a cada iteração o algorítmo busca eliminar o melhor planeta
 até o momento (neste caso, aquele cuja eleminação criará uma aresta com
 a menor distância).
 A seguir um pseudo-código que representa sua execução:
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

// Encontra o melhor planeta a ser eliminado até o momento
\end_layout

\begin_layout Plain Layout

for(i=0 até N-K){
\end_layout

\begin_layout Plain Layout

	for(j=0 até numArestas-1){
\end_layout

\begin_layout Plain Layout

		if(distancia[j] + distancia[j+1] < tmpDistancia){
\end_layout

\begin_layout Plain Layout

			tmpDistancia = distancia[j] + distancia[j+1];
\end_layout

\begin_layout Plain Layout

			tmpPlaneta = j;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	// Desloca o vetor para o planeta eliminado
\end_layout

\begin_layout Plain Layout

	for(j=tmpPlaneta+1 até numArestas)
\end_layout

\begin_layout Plain Layout

		distancia[j] = distancia[j+1];
\end_layout

\begin_layout Plain Layout

	numArestas--;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// Dentre as distâncias calculadas, encontra a maior
\end_layout

\begin_layout Plain Layout

for(j=0 até numArestas){
\end_layout

\begin_layout Plain Layout

	if(distancia[j] > maiorDistancia)
\end_layout

\begin_layout Plain Layout

		maiorDistancia = distancia[j];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Retorna maiorDistancia;
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-código para a estratégia gulosa
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na solução proposta, o algorítmo guloso nem sempre fornece a resposta correta.
 Tomemos como exemplo o caso em que existem 9 planetas dos quais 2 serão
 conquistados sendo a distâncias 11 / 1 / 1 / 1 / 1 / 1 / 1 / 1 / 1 / 1
 / 11.
 Na solução gulosa proposta haverá seleção dos planetas com menor peso de
 distâncias.
 Para essa instância, a escolha ótima a cada iteração do algorítmo de forma
 a eliminar esses planetas não leva à solução ótima.
 A imagem abaixo mostra como o arranjo de distâncias é alterado a cada iteração
 do algorítmo:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/manoel/Documents/AEDS-III/TPs/TP2/assets/Screenshot from 2015-11-16 23:39:01.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Alteração do arranjo de distâncias a cada iteração do algorítmo guloso
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A saída do algorítmo neste caso seria 18.
 Entretanto, na solução ótima, a maior distância percorrida seria 15.
 Como o algorítmo guloso toma uma decisão que aparentemente leva à solução
 ótima em um dado momento e não volta atrás na mesma, caso exista um planeta
 cuja não visitação implicasse em uma sub-distância menor, esta possibilidade
 não será considerada.
 
\end_layout

\begin_layout Standard
// Discutir testes para o qual da certo.
\end_layout

\begin_layout Subsection
Força Bruta
\end_layout

\begin_layout Standard
A estratégia de solução do problema por força bruta consiste simplesmente
 em gerar todas as possíveis combinações de K planetas no conjunto de N
 unidades.
 Para cada combinação gerada é verificada qual a maior distância percorrida
 pela nave ao visitar os planetas em questão na combinação formada.
 Este valor é registrado e então comparado e atualizado a cada combinação
 até que se encontre o menor valor para a maior distância percorrida.
 Tomando como exemplo a seguinte entrada, sendo N = 3 e K = 2:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/manoel/Documents/AEDS-III/TPs/TP2/assets/entrada_simples.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Exemplo de instância
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
temos como resultado as seguintes combinações:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Planetas a visitar
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Distância Máxima percorrida
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1, 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1, 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2, 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Depois de analisada cada combinação e calculada a distância máxima percorrida,
 é feito uma busca pela menor distância dentre as distâncias encontradas.
 No caso em questão, a solução ótima consiste em visitar os planetas 2 e
 3, sendo a maior distância igual a 3.
\end_layout

\begin_layout Standard
Este é um algorítmo que não se mostra muito eficiente para grandes instâncias,
 uma vez que o número de combinações pode ser muito grande.
 Dado o conjunto de N planetas sendo K o número de visitados, o total de
 combinações é dado por 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
C=\frac{N!}{K!(N-K)!}
\]

\end_inset


\end_layout

\begin_layout Standard
A seguir está descrito o pseudo-código para a solução implementada:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-código da força bruta
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Análise de custo
\end_layout

\begin_layout Subsection
Análise Teórica do Custo Assintótico de Tempo
\end_layout

\begin_layout Subsubsection
Algorítmo Guloso
\end_layout

\begin_layout Subsubsection
Força Bruta
\end_layout

\begin_layout Subsection
Análise Teórica do Custo Assintótico de Espaço
\end_layout

\begin_layout Subsubsection
Algorítmo Guloso
\end_layout

\begin_layout Standard
O algorítmo guloso necessita de uma cópia do arranjo de distâncias para
 que sejam feitos os cálculos das distâncias a serem percorridas ao eliminar
 os N - K planetas e armazenar o resultado neste vetor.
 Tendo em vista que o arranjo de distâncias é duplicado, temos um consumo
 de memória equivalente à 
\begin_inset Formula $O(n+n)$
\end_inset

.
 Portanto, a complexidade espacial deste algorítmo é 
\begin_inset Formula $O(N)$
\end_inset

, sendo N a quantidade de planetas da entrada.
\end_layout

\begin_layout Subsubsection
Força Bruta
\end_layout

\begin_layout Standard
O algorítmo implementado por força bruta se baseia em um arranjo de tamanho
 N e um de tamanho K para gerar as combinações.
 Para cada combinação gerada é criado um vetor que realiza a marcação de
 quais planetas serão visitados.
 Tendo como base este vetor, é feita sobre uma cópia da entrada a unificação
 das arestas correspondentes ao planetas que não serão visitados de forma
 a obter a maior distância que será percorrida para a combinação em questão.
 Logo, o consumo de memória cresce linearmente com o tamanho da entrada.
 Portanto, assintoticamente, a complexidade espacial da estratégia de força
 bruta é 
\begin_inset Formula $O(N)$
\end_inset

.
\end_layout

\begin_layout Section
Análise experimental
\end_layout

\begin_layout Standard
A análise experimental para cada implementação foi feita variando-se a quantidad
e de planetas na rota (N) e a quantidade de planetas visitados (K).
 O tempo gasto pelo algorítmo foi medido pelo comando time do Linux.
 Esta ferramenta retorna o tempo gasto na execução de um comando.
 O experimento foi feito em uma máquina com processador Intel Core i3 2.3
 GHz e 4 GB de memória RAM.
 Os resultados obtidos para cada implementação estão dispostos a seguir:
\end_layout

\begin_layout Subsection
Algorítmo Guloso
\end_layout

\begin_layout Standard
Para avaliar a estratégia gulosa, primeiramente foi variado o número de
 planetas entre 1000 e 15000 e o número de planetas conquistados foi mantido
 em 0 para que fosse possível observar o comportamento quadrático da solução,
 uma vez que são feitas N-K iterações de forma a selecionar os planetas
 a serem desconsiderados com base em suas distâncias.
 O resultado pode ser observado no gráfico abaixo à esquerda.
\end_layout

\begin_layout Standard
Ao variar a quantidade de planetas visitados (K), pode-se notar que o algorítmo
 roda de forma mais eficiente, uma vez que, a medida de o valor de K aumenta,
 são necessárias menos iterações para buscar quais planetas serão ignorados.
 Nesta análise o valor de planetas foi mantido em 15000 e a quantidade de
 planetas conquistados é variada de 1000 à 15000.
 O resultado pode ser verificado o gráfico abaixo, à direita.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/manoel/Documents/AEDS-III/TPs/TP2/assets/planetas_AG.png
	scale 50

\end_inset


\begin_inset Graphics
	filename /home/manoel/Documents/AEDS-III/TPs/TP2/assets/planetas_conqAG.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Variação do tempo de execução do algorítmo baseado em estratégia gulosa.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Força Bruta
\end_layout

\begin_layout Standard
Na análise experimental do algorítmo baseado em força bruta, a quantidade
 de instâncias foi menor em função da complexidade fatorial da solução.
 Para avaliar o tempo de execução, a quantidade de planetas foi variada
 de 10 à 100, variando de 10 em 10.
 Para estes casos, a quantidade de planetas a ser visitado foi mantida em
 5.
 O resultado está descrito no gráfico abaixo, à esquerda.
 
\end_layout

\begin_layout Standard
Para estudar o impacto do valor de planetas visitados, foram criadas entradas
 com valor de N igual a 40 e o valor de K foi variado de 2 até
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/manoel/Documents/AEDS-III/TPs/TP2/assets/planetas_FB.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Variação do tempo de execução do algorítmo baseado em força bruta
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusão
\end_layout

\begin_layout Standard
Por meio deste trabalho prático foi possível observar experimentalmente
 como se comportam algorítmos implementados a partir de diferentes paradigmas
 de programação, tanto com relação à otimalidade da solução apresentada
 bem como sob a perspectiva da viabilidade de cada algorítmo para entradas
 diferentes.
 Foi possível notar que algorítmos gulosos, apesar de terem fácil implementação
 e serem relativamente eficientes, nem sempre chegam à solução ótima em
 função de características particulares das instâncias a serem resolvidas.
 Os algorítmos de força bruta, por sua vez, apesar de terem a garantia da
 otimalidade na solução apresentada, podem se tornar inviáveis para instâncias
 maiores, já que a natureza de implementações deste tipo consiste em buscar
 em todo espaço de solução a solução ótima.
 Em problemas combinatórios, como o caso deste trabalho prático, este tipo
 de abordagem pode ser proibitivo para grandes instâncias, uma vez que a
 complexidade assintótica pode chegar a ser de ordem fatorial.
 
\end_layout

\end_body
\end_document
